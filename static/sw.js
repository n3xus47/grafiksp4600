const CACHE_NAME = 'grafiksp4600-v1.1.0';const urlsToCache = [ '/', '/signin', '/static/style.css', '/static/app.js', '/static/PKN.WA.D.png', '/static/icon-48.png', '/static/icon-72.png', '/static/icon-96.png', '/static/icon-144.png', '/static/icon-192.png', '/static/icon-512.png', '/static/favicon.ico', '/static/manifest.json' ];const VAPID_PUBLIC_KEY = 'BIvhQxAeGQGHEfdZRg8c1DyFQ2i35xL-ZBlfVz8GO4u8UxSVbWeCVACXpBi7_L7nDQJl3nxMoIYSPNJDn8xOsBQ';const urlB64ToUint8Array = (base64String) => {const padding = '='.repeat((4 - (base64String.length % 4)) % 4);const base64 = (base64String + padding).replace(/\-/g, '+').replace(/_/g, '/');const rawData = atob(base64);const outputArray = new Uint8Array(rawData.length);for (let i = 0;i < rawData.length;++i) {outputArray[i] = rawData.charCodeAt(i)} return outputArray};self.addEventListener('install', event => {console.log('Service Worker: Instalacja rozpoczęta');event.waitUntil( caches.open(CACHE_NAME) .then(cache => {console.log('Service Worker: Cache otwarty');return cache.addAll(urlsToCache)}) .then(() => {console.log('Service Worker: Wszystkie pliki zostały zacachowane');return self.skipWaiting()}) )});self.addEventListener('activate', event => {console.log('Service Worker: Aktywacja rozpoczęta');event.waitUntil( caches.keys().then(cacheNames => {return Promise.all( cacheNames.map(cacheName => {if (cacheName !== CACHE_NAME) {console.log('Service Worker: Usuwam stary cache:', cacheName);return caches.delete(cacheName)} }) )}).then(() => {return self.clients.claim()}).then(() => {return self.registration.pushManager.getSubscription().then(subscription => {if (!subscription) {console.log('Service Worker: Brak subskrypcji push, rejestruję...');return self.registration.pushManager.subscribe({userVisibleOnly: true, applicationServerKey: urlB64ToUint8Array(VAPID_PUBLIC_KEY) }).then(subscription => {console.log('Service Worker: Subskrypcja push utworzona:', subscription);return saveSubscriptionToServer(subscription)}).catch(error => {console.error('Service Worker: Błąd tworzenia subskrypcji push:', error);return null})} else {console.log('Service Worker: Subskrypcja push już istnieje:', subscription);return subscription} }).catch(error => {console.error('Service Worker: Błąd pobierania subskrypcji push:', error);return null})}) )});const saveSubscriptionToServer = async (subscription) => {try {const response = await fetch('/api/push/subscribe', {method: 'POST', headers: {'Content-Type': 'application/json', }, body: JSON.stringify(subscription), });if (response.ok) {const result = await response.json();console.log('Service Worker: Subskrypcja zapisana na serwerze:', result);return result} else {console.error('Service Worker: Błąd zapisywania subskrypcji:', response.status)} } catch (error) {console.error('Service Worker: Błąd podczas zapisywania subskrypcji:', error)} };self.addEventListener('fetch', event => {event.respondWith( caches.match(event.request) .then(response => {if (response) {return response} return fetch(event.request) .then(response => {if (!response || response.status !== 200 || response.type !== 'basic') {return response} const responseToCache = response.clone();caches.open(CACHE_NAME) .then(cache => {cache.put(event.request, responseToCache)});return response}) .catch(() => {if (event.request.mode === 'navigate') {return caches.match('/offline')} })}) )});self.addEventListener('message', event => {if (event.data && event.data.type === 'SKIP_WAITING') {self.skipWaiting()} else if (event.data && event.data.type === 'GET_SUBSCRIPTION') {self.registration.pushManager.getSubscription().then(subscription => {event.ports[0].postMessage({subscription: subscription })})} else if (event.data && event.data.type === 'SUBSCRIBE_PUSH') {self.registration.pushManager.subscribe({userVisibleOnly: true, applicationServerKey: urlB64ToUint8Array(VAPID_PUBLIC_KEY) }).then(subscription => {saveSubscriptionToServer(subscription);event.ports[0].postMessage({success: true, subscription: subscription })}).catch(error => {console.error('Service Worker: Błąd subskrypcji push:', error);event.ports[0].postMessage({success: false, error: error.message })})} });self.addEventListener('push', event => {console.log('Service Worker: Otrzymano push event:', event);let notificationData = {title: 'Grafik SP4600', body: 'Masz nową prośbę w skrzynce', icon: '/static/PKN.WA.D-192.png', badge: '/static/PKN.WA.D-192.png', data: {url: '/', timestamp: Date.now() } };if (event.data) {try {const pushData = event.data.json();notificationData = {...notificationData, ...pushData }} catch (error) {console.error('Service Worker: Błąd parsowania danych push:', error)} } const options = {body: notificationData.body, icon: notificationData.icon, badge: notificationData.badge, vibrate: [200, 100, 200], data: notificationData.data, actions: [ {action: 'open', title: 'Otwórz aplikację', icon: '/static/PKN.WA.D-192.png' }, {action: 'close', title: 'Zamknij', icon: '/static/PKN.WA.D-192.png' } ], requireInteraction: true, tag: 'grafik-notification' };event.waitUntil( self.registration.showNotification(notificationData.title, options) )});self.addEventListener('notificationclick', event => {console.log('Service Worker: Kliknięto w powiadomienie:', event);event.notification.close();if (event.action === 'open') {event.waitUntil( clients.openWindow('/') )} else if (event.action === 'close') {return} else {event.waitUntil( clients.matchAll().then(clientList => {if (clientList.length > 0) {return clientList[0].focus()} return clients.openWindow('/')}) )} });self.addEventListener('sync', event => {if (event.tag === 'check-notifications') {event.waitUntil(checkForNewRequests())} });async function checkForNewRequests() {try {const response = await fetch('/api/swaps/inbox', { credentials: 'include' });const data = await response.json();if (data.items && data.items.length > 0) {const previousStatuses = await getPreviousStatuses();const currentStatuses = {};let hasChanges = false;let notificationMessage = '';data.items.forEach(item => {currentStatuses[item.id] = item.final_status;if (previousStatuses[item.id] && previousStatuses[item.id] !== item.final_status) {hasChanges = true;const statusText = getStatusText(item.final_status);if (!notificationMessage) {notificationMessage = `Status prośby się zmienił: ${statusText}`} else {notificationMessage += `, ${statusText}`} } if (!previousStatuses[item.id] && (item.final_status === 'OCZEKUJACE' || item.final_status === 'WSTEPNIE_ZATWIERDZONE')) {hasChanges = true;if (!notificationMessage) {notificationMessage = `Masz nową prośbę w skrzynce`} else {notificationMessage += `, nowa prośba`} } });await savePreviousStatuses(currentStatuses);if (hasChanges && notificationMessage) {self.registration.showNotification('Grafik SP4600', {body: notificationMessage, icon: '/static/PKN.WA.D-192.png', badge: '/static/PKN.WA.D-192.png', tag: 'grafik-notification', data: {url: '/' } })} } } catch (error) {console.error('Service Worker: Błąd sprawdzania nowych próśb:', error)} } async function getPreviousStatuses() {try {const cache = await caches.open('grafiksp4600-statuses');const response = await cache.match('/statuses');if (response) {return await response.json()} } catch (error) {console.error('Service Worker: Błąd pobierania poprzednich statusów:', error)} return {}} async function savePreviousStatuses(statuses) {try {const cache = await caches.open('grafiksp4600-statuses');await cache.put('/statuses', new Response(JSON.stringify(statuses)))} catch (error) {console.error('Service Worker: Błąd zapisywania statusów:', error)} } function getStatusText(finalStatus) {switch (finalStatus) {case 'OCZEKUJACE': return 'Oczekujące';case 'WSTEPNIE_ZATWIERDZONE': return 'Wstępnie zatwierdzone';case 'ZATWIERDZONE': return 'Zatwierdzone';case 'ODRZUCONE': return 'Odrzucone';case 'ODRZUCONE_PRZEZ_SZEFA': return 'Odrzucone przez szefa';default: return finalStatus} }